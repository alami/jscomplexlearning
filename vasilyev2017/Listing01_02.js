document.write("Сценарий загружается")
var txt,num
txt="<hr>Значение числа: "
num=123
document.write(txt+num)
var x="3 + (5*2 + 6) / 4"
document.write('<br>'+x+" = ")
document.write(eval(x))
var n=100; var k=1; var s=0
var txt="1<sup>2</sup> + 2<sup>2</sup> + … + "
txt+=n+"<sup>2</sup> = "
while(k<=n){    s+=k*k;     k++; }
document.write('<br>'+txt+s+'<hr>')
/*
Васильев А.Н. JavaScript в примерах и задачах  – Москва : Издательство «Э», 2017. – 720 с
,142 !! локальные переменные создаются в самом начале выполнения функции, причем вне зависимости от того,
 где именно в программном коде функции находится инструкция объявления локальной переменной.
 */
var isItGlobal = "Global"
document.write(isItGlobal+'<br>')
f()
document.write(isItGlobal+'<br>')

function f() {
isItGlobal = "Is It Global of Local ?"
document.write('f:' + isItGlobal+'<br>')
    document.write('f:' + window.isItGlobal+'<br>')
    var isItGlobal
}
//,154
f1(isItGlobal)
f1(5)
f1(true)
f1()
f1([1,2])
function f1(arg) {
    switch (typeof arg) {
        case "string":document.write('String type'+'<br>');break
        case "boolean":document.write('Boolean type'+'<br>');break
        case "number":document.write('Number type'+'<br>');break
/*,156 при вызове функции несоответствие количества переданных функции аргументов
 количеству аргументов, указанных при описании функции, само по себе не вызывает ошибки*/
        case "undefined":document.write('No argument'+'<br>');break
        default:document.write('Other type'+'<br>')
    }
}
/*,168 Главная особенность внутренней функции связана с тем,
что она имеет доступ к локальным переменным внешней функции
(эта особенность внутренних функций называется замыканием).
При этом внешняя функция не имеет доступа к локальным переменным внутренней функции.
*/
function mlog(x){
var s=0,k; var n=100; for(k=1;k<=n;k++) s-=power(-x,k)/k ; return s
    function power(z,m){
        var p=1,i;  for(i=1;i<=m;i++) p*=z ;  return p
    }
}
var x=0.5
document.write("<hr>Вычисление логарифма: ln(1+"+x+") = " + mlog(x) + "<br>")
document.write("Проверка: "+Math.log(1+x)+"<hr>")
/*,174 Функции на самом деле являются объектами.
воспользуемся маленьким побочным эффектом:
 - функции можно присваивать значениями переменным. Более того
 - имени функции также можно присвоить новое значение,
     причем, совсем не обязательно должно быть функцией.
2) => имя функции удобно интерпретировать как ссылку на функцию.
1) 2 прохода...

*/
show("Вызов Ф-ции show()")
var f
f=show
f("Теперь это ф-ция f()")
show="А теперь Текстовое значение"
// show("Вызов Ф-ции show()") <--Uncaught TypeError: show is not a function
document.write(show+"<br>")
f("Снова ф-ция f()")
function show(msg){  document.write(msg+"<hr>") }

var f=function(msg){  document.write(msg+"<hr>") }
f("Анонимная ф-ция")
//!! (function(msg){document.write("<b>"+msg+"</b><hr>")}("Еще Анонимная ф-ция"))
/*,183 Внешние круглые скобки нужны,чтобы «объединить» код создания функции и скобки с аргументом в одно целое.
1) «одноразовая»
2) создается она в том месте, где в сценарии размещена команда создания функции,
    т.е.не при 1 проходе, и нельзя вызвать до...

,186 функция результатом может возвращать другую функцию. Откуда ?
1) внутреннюю (не-анонимная) функцию,
2) анонимная функция.
*/
function makePolynom(a,b,c){
    return function(x){ return a+b*x+c*x*x  } //Полином второй степени - анонимная функция
    }
var P,Q
P=makePolynom(1,2,1)
Q=makePolynom(2,-1,1)
var z=2
document.write("P("+z+") = "+P(z)+"<br>")
document.write("Q("+z+") = "+Q(z)+"<hr>")

function makeFibs(){ //последующее число = сумме 2х предыдущих
    var a=0,b=1
    return next       // Результат внешней функции
    function next(){  // Внутренняя функция - каждый вызов
        b=a+b; a=b-a  // изменяет значения локальных переменных внешней функции
        document.write('<sup>b='+b+'</sup>')
        return a      // Результат внутренней функции
    }                 // Окончание описания внутренней функции
}                     // Окончание описания внешней функции
var nextFib=makeFibs() // В переменную записывается результат вызова функции
for(var k=1;k<=15;k++){
    document.write(nextFib()+" | ") // Генерирование чисел Фибоначчи
}  /*--15 последовательных вызовов ф-ии next()
     - кот-ую возвращает makeFibs, да еще и хранит предыдущие a, b */
/*,196 в JavaScript есть объекты, но нет классов (в их традиционном понимании)
при постройке небоскреба желательно использовать более продвинутую технологию,
чем выкладывание стенок и перегородок из кирпичей.
Разумнее использовать уже готовые блоки.
Причем блоки должны быть функциональными — например, с окнами, дверьми,
разъемами для выключателей, с предусмотренной системой креплений и другими полезными штуками
Также в объект «спрятаны» различные переменные (тн поля или свойства)
 и функции (тн методы объекта,) для обработки их значений
=> Программа - набор инструкций, которыми создаются объекты,
 кот. взаимодействуют между собой и с «окружающим миром» через методы.
Класс - некий шаблон, на основе которого создается объект (произвольное кол-во).
Объекты явл-ся физически разными,но имеют одинаковые наборы свойств и методов.
В JavaScript классов нет. Как создаются?
1) просто «с нуля» (литерал)
2) уже много встроенных
3) путем наследования от родительского прототипа
-1) Литерал объекта — список, заключенный в фигурные скобки.
Внутри  пары - название свойства : значение свойства.
Если литерал объекта присвоить в качестве значения переменной,
    var переменная={свойство:значение,свойство:значение,…}
значения свойств объекта точно так же, как изменяются значения обычных переменных

,202 функции vs метод:
  Методу не нужно передавать аргумент, и метод вызывается из объекта,
  что автоматически обеспечивает корректность доступа к свойствам объекта.
,204 добавление метода в объект эквивалентно добавлению свойства, значением которого является функция
,205 this является ссылкой на объект, из которого вызывается метод.
obj - явная ссылка на объект, указывает на один и тот же совершенно конкретный объект.
   и пока речь идет об одном-единственном объекте проблемы нет.
*/
var obj={name:"Ivan Petrov",
    age:38,
    show:function(){
        document.write("<hr><b>Name</b>: "+this.name+"<br>")
        document.write("<b>Age</b>: "+this.age+"<br>")
    }
}
obj.show()
obj.age++
obj.show()
objNew = obj;
objNew.age++;
obj.show()
/* Свойства и методы объекта не обязательно указывать сразу при его создании
Для добавления в объект свойства достаточно присвоить этому свойству значение.
Но если объектов много, а набор свойств и методов у них одинаков,
то процедура создания через литералы утомительна
=> описать специальную функцию, т.н. конструктор объектов.
,220 Объект аналогичен массиву, но только ассоциативному —
то есть массиву, у которого индексами могут быть не только целые числа,
                    но и значения иных типов (например, текст).
 */
// Функция - конструктор объектов:
function Fellow(name,age){
// Значение свойства name:
    this.name=name
// Значение свойства age:
    this.age=age
// Метод show():
    this.show=function(){
        document.write("Имя: "+this.name+" ")
        document.write("Возраст: "+this.age+" ")
    }
}
// Создание объектов с помощью конструктора:
var objA=new Fellow("Иван Петров",38)
var objB=new Fellow("Петр Иванов",39)
// Проверка значений полей объектов:
objA.show()
objB.show()
/* ,228 Каждому объекту в JavaScript автоматически в соответствие ставится другой объект,т.н.прототип.
чтобы определить, какие у объекта есть свойства и методы.
в JavaScript разделение на свойства и методы достаточно условное.
две категории: собственные и унаследованные (от прототипа)
=> иерархия прототипов, матрешка до самого "главного" - Object.prototype.
        var объект=Object.create(прототип)
 */
var X={  // Объект для использования в качестве прототипа:
    color:"красный",
    number:123,
    show:function(arg){
        document.write(""+arg+": ")
// ,235 в операторе for-in перебираются не только собственные свойства объекта,
// но и свойства, унаследованные им из прототипа.
        for(var s in this) //отображаются значения всех свойств объекта,
            if(s!="show")  // за исключением свойства себя
                document.write(s+" -> "+this[s]+" | ")
        document.write("<br>")
    } } // Окончание описания объекта-прототипа
var A=Object.create(X)  // Первый объект:
var B=Object.create(X)  // Второй объект:
    showAll()           // Проверяем свойства объектов:
A.color="желтый" // Присваиваем новые значения свойствам объектов:
A.number=321
B.color="зеленый"
    showAll()         // Проверяем свойства объектов:
X.name="прототип" // Добавление свойства name в объект-прототип:
A.state=true      // Добавление свойства state в первый объект:
    showAll()         // Проверяем свойства объектов:
delete X.number   // Удаляем свойство number объекта-прототипа:
delete A.color    // Удаляем свойство color первого объекта:
    showAll()         // Проверяем свойства объектов:
delete X.color; showAll()
function showAll(){  // Функция для отображения свойств объектов:
  X.show("X"); A.show("A"); B.show("B"); document.write("<hr>"); }
/* ,236 добавление свойства в прототип добавляет это же свойство (и значение)
        во все объекты, созданные на основе данного прототипа.
Технически свойство появляется у объекта X, а у объектов A и B такого собственного нет !!

Object.getPrototypeOf() - ссылку на прототип объекта
Object.prototype -  свойство,которое позволяет получить доступ к прототипу верхнего уровня
    => Object.getPrototypeOf(Object.prototype) = null
Добавление свойств во все объекты, через добавление свойств в прототип верхнего уровня !!
 */
var txt='"name" in Math'
document.write(txt+" -> "+eval(txt)+"<br>")  //=> false ,239
Object.prototype.name="объект À"
document.write(txt+" -> "+eval(txt)+"<br>") //=> true
/* объект может быть создан совсем без прототипа.
        var obj=Object.create(null)
Object.setPrototypeOf() - который позволяет задавать прототип для объекта
 */
var A={}                  // Пустой объект "A" с прототипом:
var B=Object.create(null) // Пустой объект "B" без прототипа:
var C=Object.create(B)    // Пустой объект "C" с явно указанным прототипом:
B.number=100              // Добавление свойства number в объект "B":
Object.prototype.name="Объект А" // Добавление свойства name в прототип верхнего уровня:
document.write('<hr>')
show1(A)  ; show1(B) ; show1(C)   // Отображение свойств объектов:
function show1(obj){
    for(var s in obj) document.write(s+" -> "+obj[s] +" | ")
    document.write("<br>")
}
/*,251 все объекты, созданные с помощью некоторого конструктора, имеют один общий прототип
=> можем добавлять и удалять свойства в эти объекты путем выполнения соответствующей операции с прототипом
- с помощью свойства prototype конструктора
        new Конструктор(аргументы)
        Конструктор.prototype

 */
function MyObj (name,number){  //[просто ф-ция - и уже конструктор :) ]
    this.name=name
    this.number=number
    this.show=function(){
        for(var s in this)
            if(s!="show") document.write(s+" -> "+this[s]+" | ")
                document.write("<br>")
    }  }
var A = new MyObj('Obj A',100)
var B = new MyObj('Obj B',100)
var C = {}
Object.prototype.dbg = "DBG"
A.show(); B.show(); show1(C)
/*,251 собственными свойствами данного объекта, но тут же
можно получить доступ к прототипам объектов, созданных на его основе,
        myObj.prototype - сам объект прототип, используемый в "new"
В то время как
        Object.getPrototypeOf ( MyObj ) - прототип "MyObj" [как ни странно - ф-ция]
*/
        MyObj.prototype.color="transparent";   A.show(); B.show();
        A.color="white"
        delete MyObj.prototype.color;   A.show(); B.show();
/*,254 по объекту определить конструктор,
который позволяет создавать объекты с таким же прототипом, как у данного.
ниже 3 способа создания объектов: 1) с помощью явно описанного конструктора,
2) с помощью литерала и 2)с помощью анонимного конструктора (и сразу вызов)
 */
document.write("<hr>")
function MyObj1(){   //Constructor
    this.number=0
}
var A=new MyObj1()    //-1)
var F=A.constructor //определить конструктор объекта "A"
var B=new F()       //новый
        document.write("Свойство B.number = "+B.number+"<Br>")
A={}                //-2)
F=A.constructor
        document.write("F==Object -> "+(F==Object)+"<br>")
A=new function(){      //-3
    this.name="object"//Круглые скобки после описания анонимной функции
                }()  // в команде создания объекта означают, что она вызывается.

F=A.constructor
B=new F()
        document.write("Свойство B.name = "+B.name)

