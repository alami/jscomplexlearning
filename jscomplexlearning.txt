---------------------------------------------------------------------------------------
Мелюков Сергей
Главный преподаватель курса «Senior Engineer фронтенд архитектуры в компании Avito»
«Комплексное обучение JavaScript»
Введение
0-00
1-04
---------------------------------------------------------------------------------------
01 Вебинар — Введение
02 Git
03 Как работает JavaScript
04 Переменные и функции
05 Вебинар — Практика
06 Объекты и массивы
07 Обработка ошибок
08 Вебинар — Практика
09 DOM
10 Асинхронность
11 Вебинар — Практика
12 Работа с сетью
13 Browser API
14 Вебинар Практика
15 Работа с VK API и шаблонизация
16 ООП
17 Вебинар Практика
18 MV-паттерны
19 Модули
20 Вебинар Практика
21 Вебинар Node.js (краткое знакомство)
22 Тестирование JS-кода 
23 Вебинар — Практика (Закрытие)
---------------------------------------------------------------------------------------
01 Вебинар — Введение
---------------------------------------------------------------------------------------
02 Git
1. Введение.mp4
	 7-00
2. Установка. Настройка.mp4
3. Инициализация.mp4
4. Добавление файлов.mp4
5. Первый коммит.mp4
6. Отмена изменений.mp4
7. Типичный цикл работы с git.mp4
8. Ветки. Создание и слияние.mp4
9. Конфликты при слиянии.mp4
10. Временное сохранение.mp4
11. Работа с GitHub.mp4
	20-00
12. GitHub Pages.mp4
links.txt
Система контроля версий Git Справочник.pdf
Система контроля версий Git часть I.pdf
Система контроля версий Git часть II.pdf

---------------------------------------------------------------------------------------
03 Как работает JavaScript
8-00 Render Engine HTML/CSS
     Script Engine JS
9-00 --шаги--- напр.,  var a = 1 + 1
Парсинг      - разбиение, | var | a | = | 1 | + | 1 |
Генерация AST- VariableDeclaration
-древовидная     -Indetifier (a)
структура        -BinaryOperator (+)
                    -Literal (1)
                    -Literal (1)
Трансляция   - 1010101010010101
Оптимизация  - 11100001+
Выпонение
13-42 IDE, linter, .. работают с помошью 1б шагов
14-20 и сборщики (webpack)
15-23 EcmaScript 262 - спецификация++
      JavaSCript     - тех.реализация спец-ии
16-29 2009 | ES5
      2015 | ES6 (EC-2015)
      2016 | ES7 (EC-2016)
      2017 | ES8 (EC-2017)
19-53 TC-39 : контрибьютор: Strawman-Proposal-Draft-Candidate-Finished - вкл в стандарт
24-00
---------------------------------------------------------------------------------------
04 Переменные и функции
---------------------------------------------------------------------------------------
1. Переменные.mp4
var name = 'Sergey'
2. Функции.mp4 - кофемолки
3. Область видимости и замыкание.mp4
 var someVar = 20;      ---глобальные переменные :someVar, someOtherVar,sum
 var someOtherVar = 30; --/
 function sum (a,b) {  --2 параметра--2 области видимости
  result = a+b;   --1 переменная ---/    = список пременных кот.сейчас доступны
  return result;       --собственная : a,b,result
  }
2-51 Каждая ф-ция помнит где была объявлена (область видимости)
                и помнит список доступных переменных !!, где была объявлена [стек]
   напр "sum" помнит a,b,someVar, someOtherVar
3-47 function sum (a,b) {
       result = a+b + someVar + someOtherVar; //т.к.нет в ф-ции, подымается выше...
       return result;
       }
7-21 ==> замыкание  == 2-51
    a=10 //-------------замыкание
    function fn1(b,c) {
        function fn2(d,e) {
            return a+b+c+d+e
        }
        return fn2(3,4)
    }
    console.log(fn1(1,2))
4. Всплытие hoisting.mp4 - всплывает все объявления перемненных
5. Типы объявления функций.mp4
    function declaration - всплывает ф-ция полностью...              ....=> сработает
    function expression -  всплывает только объявление перемненой - но не присвоение,
                            т.е. такая ф-ция написанная позже применения => не сработает
                          - ф-ция объявляемая в контексте др.выражения
6. Стрелочные функции.mp4 - ES6
    var sum1 = function (a,b)    { return a+b }
    var suma =          (a,b) => { return a+b }  //если 1 выражение - убрать {return..}
    var sumb =          (a,b) =>  a+b
    console.log(sumb(10,20))
    var ar = [1,2,3,4]
    console.log( ar.map (function (n) {return n*n }) )
    console.log( ar.map ((n)=> n*n ) )           //если 1 параметр - убрать ()
    console.log( ar.map (n=> n*n ) )

7. Let.mp4 - не всплывает ! => доступны только в блоке где объявлены,
8. Const.mp4
Методичка — Функции.pdf
---------------------------------------------------------------------------------------
05 Вебинар — Практика - Вопросы
12-19 Счетчик function retCnt1(init) {
                  var cnt=init
                  return function () {
                      return ++cnt     } }
              f1 = retCnt1(0) --2 области видимости - разные "cnt", ф-ции,..
22-00         f2 = retCnt1(0) -/    !! и даже переменные когда загнали при объявлении
              console.log(f1()) //1        и только при объявлении !!
              console.log(f1()) //2
              console.log(f1()) //3
              console.log(f2()) //1
1-04 const Объекты -  не можете менять сам объект, но значение можно

Ф-ция с неиз.кол-вом аргументов, можно исп-ть массив
    function sum (numbers) {
        let result = 0;
        for (let i=0; i<numbers.length;i++) {
            result += numbers[i]
        }
        return result
    }
    const result = sum([2,2,5,7,9])
    console.log(result)
1-12-00 а можно исп-ть arguments - специальная переменная - в любой ф-ции, кроме стрелочной
1-13-41   - объект оч.сильно похож на массив (притворяется), с числовыми ключами
    arguments = {'0':2,'1':2,'2':5,'3':7,'4':2, length:5}

1-16-00 Рекурсия - зеркало в зеркале
    стек вызовов ф-ций ||||||||  <->
1-25 а если неизвестно кол-во ф-ций, или
   вызывает сама себя - рекурсия - вообще бесконечно
   => надо основить => контролируемая рекурсия
   еще надо возращать значение ф-ций

---------------------------------------------------------------------------------------
06 Объекты и массивы
---------------------------------------------------------------------------------------
1. Строковая интерполяция.mp4   ES6 =- спец маркеры, как в шаблонах:
       `${name} ${lastname} (${age})`
2. Объекты.mp4 - позволяет хранить не 1, а неск-ко значений данных
    var o = {name: 'Serg', lastname: 'Mel', age: 40}
              имя:значение
  обращение: 1) точечная нотация,2) скобочная
3. Массивы.mp4 - спец тип объектов для храниния упорядоченно
   var ar = []
   обращение: ar[0]
4. Деструктурирующее присваивание для Массива :
5-57 var [a,b] = [1,2]
   [переменные]=[массив]
9-31 var input = 'Sergey Petrov'
     var [name, lastname] = input.split(' ')
     var [ , lastname] = input.split(' ')
21-17 function hi ([ ,name, secondname='' ]) {
        console.log(`Hi, I am ${name} ${secondname}`)
        }
      hi (input.split(' '))
5. Деструктурирующее присваивание- Объекты.mp4
  - аналогично, но порядок не имеет значение, а только имя переменной
  => не нужно пропусков для ненжных переменных, также можно задавть умолчания
        user = {name:'Sergey', secondname: 'Petrovich'}
        var {name, secondname} = user
        console.log(`Hi, I am ${name} ${secondname}`)
6. Spread-оператор.mp4 - превратить массив "numbers" при ОБРАЩЕНИИ к ф-ции
          в парамерах ф-ции в список аргументов ,т.е. разбросать
      sum (...numbers)
7. Rest-оператор.mp4 - похож на Spread-оператор, но в ПАРАМЕТРАХ ф-ции
      function sum (first, ...rest)
      var [first, ...rest] = [1,2,3,4]  -- или просто для перемнных кода
8-59 объединить массив
    numbers = [1,2,3,4]
    number2 = [5,6,7,8]
    var result = numbers.concat(number2)  = [...numbers,...number2]
8. Цикл for-of.mp4
9. Symbol. mp4 - сгенерировать - исключить конфликты имен, не видны в for-of
    Зачем, например:
7-00 Итераторы - кусок кода, кот умеет ЧТО-ТО перебирать (Продвинутая тема)
12-00 - основная концепция JS => for,for-of,spred, rest.. 
var interator = {
  next() {  ---основной метод
    return {value: 1,
            done: false
            }
  }
}
20-41 arguments - спец объект с итератором - внутри
    но как узнать что он есть в объекте ? => Symbol.iterator

_06 links.txt
_06 Методичка — Объекты и массивы.pdf
---------------------------------------------------------------------------------------
07 Обработка ошибок
---------------------------------------------------------------------------------------
1. Инструменты браузера.mp4
2. Обработка ошибок.mp4
13-00 ф-ция по умолчанию всегда "return undefine"
     напр.,  если ф-ция не находит никаго "return .."
20-00 пытались обрабтать искл.ситуации
21-23 isFinite() -----
22-43 ..аж 4 проверки, на разных языках, понять что конкретно произошло
24-24     => нужен искл.мех-зм - генерировать спец.объекты, отдавливать,...
25-26 try ..catch.. - всегда в паре
26-12 throw new Error('строка сообщения') - пометка о странном проишествии
      => переход в ..catch (e) {e.'строка сообщения'..
3. Стек вызовов.mp4
1-33 call stack -> пирамидка то прибавляется ---> , то умен. <-----
3-00 глубина стека
11-45 НО в случае throw new Error() будет искаться ближайший  try ..catch..,
 т.е. программы в стеке не будут продолжаться, а  выбрасываться из стека до ближайшего try ..catch..,



4. Отладка.mp4
_07 links.txt
_07 Методичка Обработка ошибок.pdf
---------------------------------------------------------------------------------------
08 Вебинар — Практика
        присваивание Объектов
        удаление элеентов массива
        map/set
Q: console.time('1')  ... console.timeEnd('1')
10-35 $('div')       --1-ый элем
     $$('.divclass') --все элементым с таким классом->[массив]
     $0 - тек.кот выбран во вклдке "Elements"
     $1 ... - предыдущий...., кот выбран во вклдке "Elements"
13-19 Q: throw  <-> try-catch  -- важно только 2 момента в коде:
 1) выброс исключения    - 1 код->throw, - ! не надо здесь же обрабатывать !
 2) обработка исключения -другое место, где используем "опасное" выражение - обрамляем try-catch
   чтобы не пролучить ERR в консоли или броузере
   но можете вообще не ловить исключение
14-47 -1) вообще не обязательно выбрасывать ERROR
try {
    throw '!!!-------!!!'//необязательно  ERROR
} catch (e) {
    console.log(e)  //<---- "e" - это объект исключения, все что угодно, напр. "строка"
}
15-02 ERROR - это семантическая штука, от нее можно наследовать класс MyError,
   напр. видеть стек по которому он прошел, просто яснее чем обычная  "строка"

17-06 Q: reduce - из мн-ва значений сделать 1, напр, сумму
    a=[1,2,3,4] //_всегда передается 1)рез-т предыдущей операции(начиная с 1го), 2)тек.элем
    b=a.reduce((all,currect)=>{
        return all += currect
    },100)
24-25  ^----есть еще 3ий - элем, кот.передется на 1ой итерации =>[т.е.циклов на 1 больше]

26-52 Q: elem1.append(elem2)  заменить на innerHTML
29-13 Q: Symbol Iterator - не в любом объекте
    for (const elem of {
        foo: 1, bar:2, [Symbol.iterator]() {
            return {
                next() {
                    if (this._first++<2)
                          return {value: this._first, done: false}
                    else return {done: true}
                },
                _first: 0
            }
        }
    }) {console.log(elem)}
29-42 ---присваивание Объектов
30-42 foo, bar - метапеременные, чтобы не исп-ть св-во1, ..2,..., чтобы на их примерах что-то демонстрировать
33-37 JS в переменной под объект [не примитив] хранится адрес, а не сам объект
=> a=b будут хранить не 2 копии объекта, а 2 адреса на 1н объект

--- https://medium.com/devschacht/daniel-li-not-everything-in-javascript-is-an-object-82fe5026e1a2 ---
В JavaScript существует 6 примитивных типов данных
 - не имеют методов
 - сохраняются как значения, в отличие от объектов, хранящихся в качестве ссылки
1) Булевые значения — true или false 2) null 3) undefined
4) number - 64-битный флоат (в JavaScript нет целых чисел) 5) string
6) symbol (появился в ES6) +7) хранилище ключей const object = { key: "value" } (в ES)
Функция — это особый тип объекта
  - со специальными свойствами [Метод ?], например, constructor и call.
                          - Метод — это свойство объекта, являющееся функцией.
  - И как к обычным объектам, вы можете добавлять новые свойства
Объекты-оболочки - String, Number, Boolean, Function
 - сущест-ют для соответствующих типов
 - и есть одноименные функций, как
  => JavaScript не возмущается, когда пытаетесь получить  длину,
     присвоить свойство примитивному типу или сравнить его с объектом, ...
     потому что присвоение выполняется на временном объекте-оболочке,
     (Автоупаковка (autoboxing) - потом удаление),
     а не на самом примитивном типе.
 =>
-----------------------------------
36-07 копировать/клонировать через спред  const b = {...a}
    т.е. как с массивами
37-03 но с вложенными объектами, опять будут указывать на 1 и тот под-объект
37-32 я  использую рекурсию для вложенного клонирования

38-17 это касается массивов и ф-ций

43-29---удаление элементов массива <> св-ва объекта
delete ab.bar  ---> { foo: 1, bar: 3 } ==> { foo: 1 }
delete  a[1]  ----> [ 1, <1 empty item>, 3, 4 ]
46-06 => a.splice(1,1)                         - вырезает и/или добавляет элементы
          начало--^ ^--и сколько /----и потом список вставки (! НЕ замены) туда же =>
49-00   a.splice (1,0, "hel", "JS") --т.е.но и добавлять => [ 1, 'hel', 'JS', 3, 4 ]

1-03-47 не путать с slice (1,3) - копирует массив - срез с 1 го по 3й элемента
                   начало--^ ^--конец
50-10 -------------------Map/Set ---------------------------------
const student = {}
54-39 - другие объекты не могут использоваться в качестве ключей,
 т.к объект нужно привести к строке, при этом выдаст  '[object Object]'
    const ss1 = {name: "Mary"}
    const ss2 = {name: "Gary"}
    const students = {}
    students [ss1] = 5    ----> students ['[object Object]']
    students [ss2] = 1    ----> students ['[object Object]'], т.е одно и то же !
    console.log(students, students [ss1]) ---->  { '[object Object]': 1 } 1
55-31 если надо чтобы объкт имел ключами др.объект => спец тип объекта - карта соотвествий
    const studentss = new Map ()
    studentss.set (ss1, 5)
    studentss.set (ss2, 1)
    console.log(studentss, studentss.get (ss1))
       Map { { name: 'Mary' } => 5, { name: 'Gary' } => 1 }       5


58-16 еще стр-ра данных ------  Set  -----------набор
 для массива только уникальных значений - достаточно также обернуть
    const arrSet = new Set ([1,2,3,4,5])  ------> Set { 1, 2, 3, 4, 5, 10 }
    arrSet.add(10)
    arrSet.add(10)
    for (const el of arrSet) console.log(el)  ---поддерживает фильтрацию for/of
вместо
     function addUserInput (ar, val) { ---без ф-ций фильтрации или логики
           if (!ar.includes (val)) ar.push (val)
       }
       addUserInput(a,10)
       addUserInput(a,10)
1-05-06 - разница в том, с чем работают
        for(i) ----------------- с перебором инд. массива
        for (const key in arr) - с перебором св-в объекта -> key, arr[key] == for(i) для объекта
        for (const el  of arrSet) - с Итератором  объекта
                  [el - уже элементы, а не индексы|св-ва --- 29-13 Q: Symbol Iterator ]

1-10-56 Symbol Iterator- это ф-ция - их использует for/of ...spred операторы
    const a {
        [Symbol Iterator](){

        }
    }
хотя        typeof Symbol Iterator === 'symbol'
---------------------------------------------------------------------------------------
09 DOM
---------------------------------------------------------------------------------------
1. DOM (Document Object Model).mp4
узлы - откр.элем. - аттрибуты - текстовый узел - др.узлы - закр.элем.
=> HTML page = DOM structurs = DOM дерево
    "document" имеет кучу команд, в каждом браузере
8-34 --найти и изменить
     const element = document.querySelector('#container')
     element.style.color = 'red'
     сonst element1 = document.querySelector('.hello')
     element1.textContent = 'Новый текст'
12-13 --создание
    const element1 = document.createElement('div')
    element1.textContent = 'Новый текст div'
    container.appendChild(element1)

2. DOM-события.mp4  <- нажатия кнопок, ссылок, мышкой по экрану
0-51 мы можем перхватывать и исполнять свой код
1-27 научимся добавлять события на разные кнопки
        const myButton = document.querySelector('#myButton')
        myButton.addEventListener('click', function (){
            console.log('клик на кнопке')
        })
9-27 (+)модификация дом-дерева
11-24 const phone = document.querySelector('#phone')
      phone.addEventListener('keydown', function (event){
          let isDigit = false
          if(event.key >= 0 || event.key <= 9 ) isDigit = true
          if (isDigit) console.log('digit')
          else event.preventDefault() --
      })
12-11 действия по умолчанию - не у всех полей, у текстовых - есть
17-27 нет реакции на <-, ->, del, ...
3. Обработка ввода.mp4
const phone = document.querySelector('#phone')
phone.addEventListener('keydown', function (event){ <--особая -всегда приходит 1 аргумент
    console.log('keydown')          - спец объект с инфо о событии
})

4. Работа с формами.mp4
2-00 без перезагрузок, доступ ко всем полям, т.е. event.preventDefault()
4-02 у любой формы есть доступ к ее элементам, через имена, вместо id, т.е.
7-08 => надо задать всем поля атрибут name="...."
        myForm.elements.lastName.value
8-42 select - все однотипно
5. Рабочий пример.mp4
20-00 так работают все интеркативное анкеты, галереи и тп
6. Обход DOM-дерева.mp4 - обращение в соседним и др элементам
    const body = document.body
    console.log(body.childNodes)
2-19 9 узлов, т.к есть 2 типа - элементы и текстовые :
 0) (текстовый)перенос строки,
 1) (элемент) ...
 7) (элемент) script
 8) (текстовый)перенос строки,
_09 Методичка DOM.pdf
4-00 нужны только элементы  , перебрать
    const body = document.body
    for (let i=0; i<body.childNodes.length; i++)
        console.log(body.childNodes[i])
childNodes - не массив, спец объект типа arguments, кот притворяется массивом
             содержит Итератор для for/of
=>  for (const node of body.childNodes)
        console.log(node)
6-34 проверяем св-во nodeType  => 1 - ELEMENT_NODE ; 3 - TEXT_NODE
    for (const node of body.childNodes)
        if (node.nodeType ===3 )      console.log('текстовый узел',node)
        else if (node.nodeType ===1 ) console.log('элемент узел',node)
8-51 еще способ отличить их вместо childNodes - все элементы наследники
   использовать children - только - элементы узлы
   (+)возмеращает тоже коллекцию с итератором - не массив

11-43 отностительно контейнра - сущ-ют 1 и последние элементы
  Напр. console.log(body.firstChild) - это может быть и текстовый элемент
13-37 но при автосборке - на это  ненадежно => исп-ть
        console.log(body.firstElementChild)
16-00 каждый элем знает о соседях
        console.log(body.firstElementChild.nextSibling) -- любой, даже текстовый
        console.log(body.firstElementChild.nextElementSibling) -- любой, даже текстовый
18-32 previous..  предыдущего
19-26 к родительскому элем контейнера
22-05 чаще в цикле, напр
<body>
<div class="class-1">
    <a href="#" id="myLink">LoftSchool</a>
</div>
<script>
    const myLink = document.querySelector('#myLink')
    let cursor = myLink
    while (cursor = cursor.parentNode)
        console.log(cursor)
Link -> div -> body -> document - самый корневой узел
25-00    и его document.parentNode = NULL, т.е. итерация заканчивается
---------------------------------------------------------------------------------------
10 Асинхронность
---------------------------------------------------------------------------------------
10-1 Таймеры.mp4 - но не блокирует выполнение кода
    setTimeout(function (){         ---интрепретатор не выполняет,
     console.log('таймер на 1 сек') ---а лишь засекает время и сохранят в очередь queue
    }, 1000)
const queue = [
    fn = function () {  console.log('123') }
    delay = 1000
    start = 87129487129581  --среда исполнения фиксирут время старта
]
8-27 но контекст кода - не очередь , а основной поток(контекст) исполнения
9-15 ! и исполнение не начнется пока интерпретатор не закончит основной код
9-31 ! не может setTimeout() вклиниваться в код
    console.log('before setTimeout')

    setTimeout(function (){
     console.log('таймер на 0.5 сек')
    }, 500)

    console.log('after setTimeout')

    console.log('before for')
    console.time('1')
    for (let i=0; i< 1000000000; i++) a = i/i  ----2,5 сек
    console.timeEnd('1')
    console.log('after for')

12-45 очередь из задач не обработывается ,пока основной поток не завершиться !!!!
      даже 10, 20 ,100 сек, никакие таймеры завершены не будут
13-27 так эмулируется асинхронность :)
14-17 setInterval () так же будут запускаться через каждый интервал, тоже после завершения осн.потока
16-23 но разницы учитывается, если таймер превышает выполнения основного потока,
  он задержится точно на эту разницу,
  при это все просроченные таймеры выполняются сразу же
18-31 здесь и пригождается св-во "start" в очереди
23-31 все это рекурсивно: если внутри ф-ции таймера еще ф-ции таймера, они тоже будут ждать конца исполнения

---------------------------------------------------------------------------------------------------
10-2 Promise.mp4
    выберем из https://www.pexels.com/ картинки :
https://images.pexels.com/photos/4862663/pexels-photo-4862663.jpeg
https://images.pexels.com/photos/5393816/pexels-photo-5393816.jpeg
https://images.pexels.com/photos/4286744/pexels-photo-4286744.jpeg
3-31 Задача состоит загрузить картинки последовательно, а не параллельно
2 варианта:
6-00 1)на callback-ах
    const url1 = 'https://images.pexels.com/photos/4862663/pexels-photo-4862663.jpeg'
    const url2 = 'https://images.pexels.com/photos/5393816/pexels-photo-5393816.jpeg'
    const url3 = 'https://images.pexels.com/photos/4286744/pexels-photo-4286744.jpeg'
    const img1 = new Image();    img1.height = 200;    img1.src = url1
    const img2 = new Image();    img2.height = 200;    img2.src = url2
    const img3 = new Image();    img3.height = 200;    img3.src = url1
    document.body.append(img1)
    document.body.append(img2)
    document.body.append(img3)
6-31 исп-ть мех-зм событий
7-02  img1.addEventListener('load', ()=>{ //--событие возникает когда картинка загружена
            //здесь можно делать что надо - 2 варианта:
        })
1)на callback-ах
8-0 const img = new Image();
    img.height = 200;
    img.src = url1
    document.body.append(img)
    img.addEventListener('load', ()=>{
        const img = new Image();
        img.height = 200;
        img.src = url2
        document.body.append(img)
        img.addEventListener('load', ()=> {
            const img = new Image();
            img.height = 200;
            img.src = url3
            document.body.append(img)
            img.addEventListener('load', ()=> {
                console.log('Все картинки загружены')
            })
          })
        })
9-20 добавим какой то trottling профайл на 3000 kb/s - для уменьшения скорости <fast3G
9-50 вроде задача решена, но код получится пирамидкой вправо - лапша,callback-hell

11-37 разберем что такое асихронная задача:
      может быть выполена, а может нет, через 1 сек или через 100 сек.
      точно предсказать нельзя
12-06 для картинок зависит от 1) скорость нашего интернета 2)..сервера 3) его доступность...

13-22 2)на promise-ах  -
13-51 аналогии - аэропорт:
1) ожидание (самолета)
2) выполнена успешно  (пройдите на посадку)
2) выполнена неудачно (вылет отменяется из-за погоды)
=> машина состоянии => promice - небольшой объектик, у кот. тоже есть состояния
15-57
const promise = {
    state: ['pending', 'fulfilled', 'rejected']
}
17-35 загрузка картинки аналогично
18-01 попробуем создать promise
    const promise = new Promise(function () { --передаем 1 ф-цию,
                                 ^--которая выполняется сразу же,
    }) .т.е.блокирующая, как только интерпретатор пытается создать Promise
19-17 --------------------------мгновенно и последовательность сохраняется
11 console.log('до Promise')
12 const promise = new Promise(function () {
13    console.log('внутри Promise')
   })
15 console.log('после Promise')
19-23 создание Promise - это всегда СИНХРОННАЯ операция !!
19-57 т.е. 11->12->13->15,
      все потому что ф-ция передаваемая в конструктор - блокирующая
20-19 Но что полезного? Ф-ция! Она не простая, есть 2 параметра-ф-ции:
   function (resolve, reject) (а можно назвать function (cat, dog) :)
20-51 главное понять смысл:
21-07 аналогии - аэропорт: что вызовет смену состояния
   - сообщение диспетчера - рычаги- "идите на посадку", "можете сдать билеты"
   эти параметры-ф-ции и есть рычаги
21-40 вызывая resolve() - переводим в состояние "resolved"
      вызывая reject () - переводим в состояние "rejected"
22-20 можете назвать как угодно,
      [но их влияние на состояние определяется местом в параметрах:1я и 2я]
22-30 можно исп-ть стрелочние ф-ции - короче
    const promise = new Promise((resolve, reject) => {
        })
22-52 можем вызвать любую из этих ф-ций и будут работать ? Да !
    const promise = new Promise((resolve, reject)  => {
            resolve() })
23-23 как только Promise создается он переводится в состояние ожидания
    вызов resolve() переводит его в состояние успешно
23-44 но естественно - делать это при определенных условиях.
24-49 function delay (ms) {
          return new Promise(resolve => {
              setTimeout(()=> {
                  resolve()
                  console.log('resolve') ---для визуализации рез-та
              },ms)
          })
      }
   delay(2000) - создасться Promise, кот будут "разрешен" через "ms" миллисек.
25-53 Зачем переводить в др.состояние (resolve) если ничего сделать не можем
   => передем к коду, который обрабатывает наши переходы
   т.е. Promise предусматривают и механизмы этих переходов,
   в момент этого перехода можно перехватить инициативу : ВЫПОЛНИТЬ некий код
26-35 выше не зря написан return, т.е. ф-ция delay() -возвращает
    новый Promise - объект у кот есть состояния
27-00 const promise = {
          state: ['pending', 'fulfilled', 'rejected'] --но еще и есть
          resolveQueue: [  --некая очередь, кот можно наполнять ф-циями
                function () {      --например этими,
                  console.log('1') --т.о.можем отловить момент перехода
                },                 --и выполнить чередь из этих 3 ф-ций
                function () {
                  console.log('2')
                },
                function () {
                  console.log('3')
                },
            ]
      }
27-55 для начала создадим переменную
    const promise = delay(2000)
28-12 у каждого промиса есть ф-ция, которая добавляет наши ф-ции в эту очередь
    promise.then( ()=>console.log('1') )
28-44 для тех кто запутался работаем интерпретатором
29-36 ...для наглядности добавим еще пару ф-ий в эту очередь
    promise.then( ()=>console.log('2') )
    promise.then( ()=>console.log('3') )

30-08 как бы выглядил промис как только его создали

33.00 сразу 2 состояния невозможны,
т.е. если после resolve(), вызвать reject(), 2ая проигнорирутся и наоборот

34-33 еще 2 примера
then () - непросто метод, кот что-то добавляет в очередь
у него 2 задачи: 1) добавить ф-цию в очередь к этому промису
2) и возвращает новый промис
    promise
        .then( ()=>console.log('1') ) --вернет совершенно новый промис
        .then( ()=>console.log('2') )
35-23 в чем разница с [29-36] <-- добавляли ф-ции в очередь 1го промиса
   ^--возвращается новый промис
36-28 const tmp = {
          state: 'pending',
          resolved: [
             ()=>console.log('1')
          ]}
36-57 const tmp2 = { --где то создается новый Promise
           state: 'pending',
           resolved: [
              ()=>console.log('2')
           ]}
37-52 и так сколько угодно - [35-23] - насколько линейный код получается
38-22 это chaining promises - цепь промисов
38-43 когда основной промис переходит в состояние fullfilled
      const tmp = {
                state: 'fullfilled',
                resolved: [
                   ()=>console.log('1') ---выполняется
                ]}
      далее  tmp2 переходит в состояние fullfilled и ...
39-19 !! then() ничего не выполняет, а только ставит в очередь
      четко понимать : then() - очередь,then() - очередь,then() - очередь,

39-55 модифицируем код с загрузкой 3х картинок
unction loadImage (url) {
    return new Promise( (resolve => {
        const img = new Image();
        img.height = 200;
        img.src = url  //--значение кот.передали в аргумент
        document.body.append(img) //--можно хранит и вне, но оставим для консистентности
        img.addEventListener('load', ()=>{   // <--а когда можно вызвать
                resolve() // т.е.выполнена загрузка картинки успешо
            })
        })
    );
}
loadImage(url1)
    .then( ()=> console.log('картинка 1 загружена'))
43-42 но надо загрузть еще картинки, поставим рядом с console.log
44-25  => бери и вкладывай друг в друга
loadImage(url1)
    .then( ()=> {
        console.log('картинка 1 загружена')
        loadImage(url2)
            .then(()=> {
                console.log('картинка 2 загружена')
                loadImage(url3)
                    .then(()=> {
                        console.log('картинка 3 загружена')
                    })
            })
       })
44-40 (-)  еще более острая пирамида чем callback-hell
45-00 чтобы уйти от этого познакомимся с еще 1й особенностью промиса :
    loadImage(url3)             /--ф-ция в в then( ... ) не очень простая
            .then(()=> {      /--- если она ничего не возвращает,
                return 123----или что то отличное от еще одного промися напр
45-50       })                \--то промисы идут выполнятся дальше - никого не ждут
46-12
loadImage(url1)
    .then(()=> {
        console.log('картинка 1 загружена')
        return loadImage(url2) --выполнится , тольок когда вернется предыдущий промис
    })
    .then(()=> {
        console.log('картинка 2 загружена')
        return loadImage(url3)
    })
    .then(()=> {
        console.log('картинка 3 загружена')
    })
47-38 что происходит когда так чейним промисы?
каждый последующий помис в цепочке выполнится , тольок когда вернется предыдущий промис
50-00 еще компактнее встрелочнх ф-ях
  loadImage(url1)
    .then(()=> loadImage(url2))  <---в стрелочных ф-ях "return" опущен !!
    .then(()=> loadImage(url3))
    .then(()=> console.log('картинка 3 загружена'))

51-43 тепер рассмотрим reject() - как обрабатывать ошибки
52-07 - переводит состояние из "ожидение" в "неудача"
52-57 можем отловить момент при помощи того же мез-зма событий
53-02 img.addEventListener('error', ()=>{   // <--произошла ошибка
        reject() // т.е.НЕ выполнена загрузка картинки или сервер выдал ее
        })
53-30 пока экспериментируем на 1 ф-ции - ничего пока не изменилось
53-42 пробуем поломать URL => 1)сразу ошибки в консоли
54-07 2)консоль говорит - есть необработанное исключение промиса
54-37 эти then() обработчики будут выполнены если состояние "успешно"
      но пришел непр.УРЛ и возникло событие "error"
      и вызвался reject(), а не resolve()
55-11 так вот у промиса есть еще 1 очередь:
      const tmp = {
                state: 'fullfilled',
                resolveQueue: [
                   ()=>console.log('1') ---выполняется при состоянии "успешно"
                ]}
                rejectQueue: [
                   ()=>console.log('1') ---выполняется при состоянии "неудача"
                ]}
56-20 [сюрприз] then() принимает 2 ф-ции-аргумента, и 2ая выполняется в состоянии "reject"
    loadImage(url1)
        .then(                              ---во 1х) then() добавляет новый промис
            ()=> console.log('картинка 3 загружена'), --вып-ся только в случай "resolve"
            ()=> console.log('не ок')          ---2) добавляет еще 1 обработчик.."reject"
        )
57-00 демо - искл.ситуация обработана
57-44 1 и тот же промис нельзяперевести в 2 состояния
58-05 но с обработкой ошибок - не все так однозначно,
58-30 а что если целая цепочка из then() и заранее не знаем где произойдет ошибка
58-45 може конечно на каждый промис
      loadImage(url1)
        .then(()=> loadImage(url2), ()=> console.log('не ок'))
        .then(()=> loadImage(url4), ()=> console.log('не ок'))
        .then(()=> loadImage(url5), ()=> console.log('не ок'))
        .then(()=> loadImage(url6), ()=> console.log('не ок'))
        .then(()=> loadImage(url7), ()=> console.log('не ок'))
        .then(()=> console.log('картинка 3 загружена'), ()=> console.log('не ок'))
59-09 неудобно - а как подерживать потом

59-31 У каждого промиса есть этот catch()
как в случае try/catch когда исключение ищет ближайший try/catch
1-00-06 демо - совершенно не важно где ошибка
[попробовал вместо 1го испортить 3й урл - сработал после загрузки 2х первых]
    loadImage(url1)
        .then(()=> loadImage(url2))
        .then(()=> loadImage(url3))
        .then(()=> console.log('картинка 3 загружена'))
        .catch(()=> console.log('не ок'))

1-00-44 catch() устанавливается на последний .then(),
 чтобы сработал на любом месте все цепочки и весь остаток .then()-ов не будут выполнен
1-01-43 Но всегда проверяется, есть ли в .then() 2я ф-ция - она будут вызвана
        и исполнение пойдет далее как будто ничего и не было
1-02-10 а catch() уже ловит все не пойманные(необработанные) ошибки в любом элементе цепи

1-02-33 еще раз: если ошибва в любом элементе цепочки - вся остальная цепочка
 будут специально проверена на обработку ошибок и, если нет!! такового, то перехад на catch()
 если же хоть где то есть - система обработает ошибку
    и все дальнейшие .then() подолжат обрабатываться штатно
     и в случае безошибочного продолжения catch() не выполнится
 т.е.catch()-выполнится, если ни в одном из элементов цепочки .then() нет обработки ошибок
1-03-28 Нам необязательно вешть обрабоку ошибок на каждый .then(),
   а просто поставить catch() кот обработает ошибку по все длине цепочки



---------------------------------------------------------------------------------------------------
10-3 Async-Await.mp4
0-33 повился неддавно в поддержке браузерами => caniuse.com
 IE -нет, Edge -c v.15 ..
0-54 неплохо полифиллятся , babel (trnspiller ES6->ES5)
1-21 все таже  ф-ция delay()
function delay (ms) {
    return new Promise(resolve => {
        setTimeout(()=>resolve(), ms)
    })
}
delay(1000)
    .then(()=>{
    return delay(1000) //--хотим задержки еще на 1 сек
    })
    .then(()=>{
        return delay(1000) //--и еще на 1 сек
    })
    .then(()=>{
        return delay(1000) //--и еще на 1 сек ...
    })
2-33 или еще укоротить
console.time('1')
delay(1000)
    .then(()=> delay(1000)) //--хотим задержки еще на 1 сек
    .then(()=> delay(1000)) //--и еще на 1 сек
    .then(()=> delay(1000)) //--и еще на 1 сек ..
    .then(()=> console.timeEnd('1')) //--------> 1: 4033.295166015625 ms

2-43 но есть синтаксический сахар - еще большего упрощения
2-55 ф-ции, кот возврщают промисы, можно предварять клюс.словом await
3-13 это заставит среду исполнения дождаться пока этот кусок кода(ф-ция)
 будет выполнен и промис будут "разрешон" и пойдет дальше
        await delay(1000)
        await delay(1000)
        await delay(1000)
4-05 трансформируется в =>
        delay(1000)
            .then(()=> delay(1000))
            .then(()=> delay(1000))
4-12 тоже самое, но есть небольшой ньюанс
    await можно использовать только внутри ф-ции кот помечно словом async
        async function fn () { --внутри этой ф-ции можно исп-ть await
            await delay(1000)
            await delay(1000)
            await delay(1000)
            await delay(1000)
            console.timeEnd('total')
        }
        console.time('total')
        fn()
async function fn () {
    console.log('до')
    await delay(1000)
    console.log('1')
    await delay(1000)
    console.log('2')
    await delay(1000)
    console.log('после')
}
18-01 =>
delay(1000)
     .then(()=> {
        console.log('до')
        delay(1000)
     })
     .then(()=> {
        console.log('1')
        delay(1000)
     }) ....
8-16 но промисы в любом виде не блокируют выполнение кода
        console.time('до FN')
        fn()
        console.time('после FN')  ---выполнится сразу, т.к. не блокирется
8-51 и только после этого выводятся все await delay()

10-52 в чем недостатки?
11-23 function delay (ms) {
          return new Promise(resolve => {
              setTimeout(()=>resolve(Math.random()), ms) //--передаем в resolve random
          })                         //--т.е.на каждый delay, ,будет возв-ся какое то значение
      }
      async function fn () {
          const r = await delay(1000)
          console.log(r)
      }
      fn()
11-31 .т.е заводим задержку на 1 сек и после через resolve() передаем случайно значение
12-07 (+)помимо обрачивания асих.кода получать просто значение как будто последовательный код
12-23 и каждый раз получаить ноавый значения
    const r = await delay(1000)
    const r1 = await delay(1000)
    console.log(r)  ---[вывести через 2 сек сразу 2 случ.значения]
    console.log(r1)
12-50 но как быть в случае reject() - как отличить от ошибки
    await становится неудобным, await, выбраcывает исключение
13-55 надо обернуть этот блок в try\catch
    function delay (ms) {
        return new Promise((resolve, reject) => {
            setTimeout(()=>reject(Math.random()), ms)
        })
    }
    async function fn () {
        try {
            await delay(1000)
        } catch (e) {
            console.log(e)
        }
    }
    fn()
15-02 (-)если гдето ошибка в цепочке, то переход все равно в catch()
16-08 следите за читаемостью кода - промисы...только помогают улучшить

10 links.txt
10-10 Методичка Асинхронность.pdf
---------------------------------------------------------------------------------------
11 Вебинар — Практика
    Document Fragment
    Делегирование событий
    Генерирование событий
---------- Document Fragment ----------
     github список городов, можно грузить fetch() запросом
2-14 https://github.com/smelukov/citiesTest/blob/master/cities.json
    конвертировать в ДОМ-дерево в список
3-53 использолвать async/await, вместо промисов
4-38 1й вар)     async function init() {
                     const response = await fetch(url)
                 }
7-05 запрос к самому файлу ,
    const url="https://raw.githubusercontent.com/smelukov/citiesTest/master/cities.json"
 а не к веб страничке "https://github.com/smelukov/citiesTest/blob/master/cities.json"

    const myButton = document.querySelector('#myButton')
    const list = document.querySelector(`#list`)
    myButton.addEventListener('click', ()=> {
        init()
    })
    async function init() {
        const response = await fetch(url)   //получаем города
        const cities = await response.json() //вынуть данные в формате json
        console.log(cities)
    }
7-49 избавимся от init()
    myButton.addEventListener('click', async ()=> {
        const response = await fetch(url)   //получаем города
        const cities = await response.json() //вынуть данные в формате json
        console.log(cities)
        for (const city of cities) {
            const li = document.createElement('li')
            li.textContent = city.name
            list.appendChild(li) --50 раз обратились в ДОМ-дерево
        }
    })
10-15 отдельный класс задач - получаем данные с сервера, и где
11-03 в list.appendChild(li) --50 раз обратились в ДОМ-дерево - дорогая операция
 => Document Fragment -контейнер, куда много раз добвляем элементы, и пототм 1 командой разом слить в ДОМ-дерево
13-02 const fragment = document.createDocumentFragment()
        for ..{
            ..
            fragment.appendChild(li) ---добавлять не в list, а fragment
        }
      list.appendChild(fragment)  ---добавить сам фрагмент
14-29 т.к. добавляется не сам контейнер, а его содержимое !!
    добавлять большое кол-во элементов за 1 заход

---------- Делегирование событий ----------
17-10 на эти города хотим повесить нажатия мышки 'click'
    li.textContent = city.name
    li.addEventListener('click', e => {  <---событие
        console.log(e.target.textContent)
    })         для кого ---^ ^---текст содержимого
19-28 можно записать и через замыкание
    li.addEventListener('click', e => {  <---событие
        console.log(li.textContent)
19-51 тоже не выгодно вешать столько обработчиков событий
20-02 => Делегирование событий на вышестоящий элемент
     погружение события - capture, всплытие события - buble
22-06 убираем и  вешаем на документ
    document.addEventListener('click', e => { --код не меняется, меняется лишь на кой элем вешаем
        console.log(e.target.textContent)
    })
23-43 но реагирует и на "кнопку" -> тект кнопки
 и даже на нажатие на пустое место -> увидеть все соджержимое стр-цы!
24-47 => отсеять только для элементов "li" - фильтрация событий
---------- Генерирование событий ----------
28-39 не нажатием клавиш и кнопок мыши, а прямо из кода (искусственные события)
33-48 const myButton = document.querySelector('#myButton')
          button.addEventListener('click', () => {
                //---button --обраб событий
              })
button = {         --наша кнопка внутри устроена так
  eventHandlers: [ --объект
    click: [       --ключ события <-значения-> массивы
        () => {..} --обработчики
        () => {..}
40-11
button = {
   eventHandlers: {},
   addEventListener (event, handler) {
    if (!this.eventHandlers.hasOwnProperty(event))  - есть ли такое св-во?
      this.eventHandlers [event] = []   //нет => надо его создать с пустым массивом
    if(!this.eventHandlers[event].includes())
      this.eventHandlers.push (handler)  // и добавить 1й обработчик событий
   }
}
42-33 1 и тот же обработчик добавить нельзя, т.е иметь только уникальные значения в массиве
   =>  можно упростить структурой "Set" =>
44-25
button = {
   eventHandlers: {}
   addEventListener (event, handler) {
     if (!this.eventHandlers.hasOwnProperty(event))
         this.eventHandlers [event] = new Set()
      this.eventHandlers.add (handler)  //--вмсесто push для массивов
45-15
  dispatchEvent (event:Event) { --если какое то событий произошло
        }
  }
4541 const event = new Event('click') --вот что делает браузер, это можем и мы
     button.dispatchEvent(event)  --создает объект и пытается обработать кнопку
--будет вызывать обработчики

52.12     const button = document.querySelector('#myButton')
          const target = document.querySelector('#target')

          button.addEventListener('click', async () => {
              const event = new CustomEvent ('loftschool')
              target.dispatchEvent(event)
          })
          target.addEventListener('loftschool', e => {
              console.log(e.type)
          })
    не только на <div> но и на "document"
53-34 есть еще removeEventListener
54-44  т.е. addEventListener - добавляеть
         dispatchEvent - перебирает event
59-00
---------------------------------------------------------------------------------------
12 Работа с сетью
---------------------------------------------------------------------------------------
12-1 Асинхронные сетевые запросы.mp4
<BUTTON id="loadButton"> Загрузить</BUTTON>
<div id="result"></div>
<script>
    const loadButton = document.querySelector('#loadButton')
    const result = document.querySelector(`#result`)
    loadButton.addEventListener('click',()=>{
        const xhr = new XMLHttpRequest()
        xhr.open('GET','content.txt')
        xhr.send();
        xhr.addEventListener('load', ()=>{
            if (xhr.status >= 404) {
                console.log('файл не найден')
            }
            else result.innerHTML = xhr.responseText
        })
    })
12-2 JSON.mp4
1-03 массив объектов -
const friends = [
    {name:'Ivan', lastName: 'Petrov'},
    {name:'Andrey', lastName: 'Ivanov'},
    ]
     можно хранить в отд.файлых - носят расширение JSON - friends.json
1-58 !! все имена и значение в 2х кавычках -> вылидный JSON
2-53 jscomplexlearning12-2.js - получим его
3-05 если из объектов сделали строку, то почему из строки не воссоздать объект ?
3-17 для этого в JS встроен спец объект JSON c 2мя методами
stringify - любой объект превращать в строку
parse - обратная операция, с кот можно рабоать: push,pop...
5-03                 const friends = JSON.parse(xhr.responseText)
5-39 самый обчный JSON массив - делать что ззотим, напр, ф-цию
    function createFriendsDOM (friend) {
        const div=document.createElement('div')
        div.classList.add('friend')
        div.textContent = `${friend.name} ${friend.lastName}`
        return div
    }
7-37 перебираем массив
9-26 повтор
10-17 упростим: XMLHttpRequest - заранее умеет принимать данные в JSON формате !
    если точно данные будут приходить в JSON формате
10-42 перед отправкой запроса
        xhr.responseType = "json"
=> не нужна конвертация
                const friends = JSON.parse(xhr.responseText)
11-17 и обращаться не к responseText, а к xhr.response
12-26 ..перед добавленим, надо бы очищать <div> от старых объектов
                result.innerHTML = ''


------------------------------
12-3 Fetch.mp4
promise - это способ оргции асинхр работы, где
 сами решаем когда промис перейдет в 1 из состояний(успех/нет)
=> можем обeрнуть XMLHttpRequest в промис - сделать универсальную ф-цию загрузки данных,
удобно рабоать как с асинхр кодом: отправка данных - ожидание получения ответа - успех/нет
все асинхр операции.
1-18 создадим fetch(url) - "загрузить", куда
 и поместим весь код реагирования на 'click' кнопки = запроса данных
1-39 но не просто, а чтобы ф-ция возвращала новый промис
 в resolve - (1ый аргумент ф-ция)  которой и поместить этот код,
    но в этой универсальной ф-цией неправильно что-то делать с ДОМ-деревом,
    поэтому вместо нее просто вызовем ф-цию resolve() [кот.потом что-то с мделает с ДОМ-деревом]
2-16 и reject - - (2ой ...), если что -то пошло нет, кот.также вызовем при "отказе"

2-33 т.о. fetch(url) это универсальная ф-ция кот принимает "url" ,
 отправляет запрос,получает ответ и если все хорошо, вызывает resolve() - состояние "успешно"
 если что погло не так, вызывает reject() - переводит промис в состояние "неудача"
3-05 вызовем fetch(url), и, т.к. возвращает промис , пишем .then()
3-31  и сразу обработаем ошибки в .catch()
4-19 но нам нужно,, чтобы файл добавлялся в ДОМ-дерево,
4-33 т.к.fetch(url) должна быть универсальной, чтобы не знала что потом делают с данными от сервера
4-48 НО доступ к переменной "xhr"  только внутри этой ф-ции fetch(url)
5-05 Познакомимся с еще 1й способностью промисов - передавать значения в callback-е(ф-ции обработчике)
5-12 Если в resolve(123) передадим какое-то значение "123" - то оно в кач-ве
      1го параметра .then((value)=>{...})
5-50 т.е.ф-ция resolve() не простая ф-ция, а туда еще можно передавать какие-то значания
6-05 => передаем всего навсего resolve(xhr.response)
6-30 т.е. приходит
7-14 PS.createFriendsDOM() переименуем в createFriendNode()
7-46 здесь можно повесить обработчики еще на 2 события: error & abort, тоже вызываем reject()
8-12 а чтобы сократить по максимуму, сразу передать reject, ведь это ф-ция
9-20 т.о.мы промисифицировали наш fetch()

9-30 в совеременных браузерах есть эта ф-ция fetch(), посмотрим
10-19 проверим в консоли > fetch
     ƒ fetch() { [native code] } --те встроенный в браузер
11-20 fetch('friends.json').then(response => {
       console.log(response)
       })
посмотрим, многочего , но нет никакого св-ва, содержащего тело сообщения, где оно?
12-02 он имеет 2 варианта ответа: "txt" и "json"
=> fetch('friends.json').then(response => {
       console.log(response.text()) ---по идее должен вернться рез-т в текстовом виде
       })                           --на самом деле возвращает новый промис
--------------------------------------------
Promise {<pending>}__proto__: Promise[[PromiseState]]: "fulfilled"[[PromiseResult]]: undefined VM180:2
Promise {<pending>}__proto__: Promise[[PromiseState]]: "fulfilled"[[PromiseResult]]: "[
  {
    "name": "Ivan",
    "lastName": "Petrov"
  },........................................
]"
12-29 т.е.мы должно на этот промис повесить еще 1 .then(), где и получим текст
12-41  fetch('friends.json').then(response => {
            response.text().then(text => {
                    console.log(text)
                    })
            })
12-55 fetch()
1).then() - возвращает объект, кот  описывает "response" от сервера,но никак не содержимое,
2) чтобы получить содержимое, надо вызвать метод .text(), кот возвращат промис,
3) применяя .then() к нему получим доступ к уже содежимому

13-07 помимо метода .text(), есть еще метод .json() .. аналогично приходит массив
13-42 возьмем поледния и скопируем е программу
14-14 итого loadButton.addEventListener('click',()=>{
fetch('friends.json') --вызываем
  .then(response => { --ждем пока прийдет ответ от сервера, промис разрешится
    response.json().then(friends => {--обращаемся к ответу,он возвращает новый промис
14-15   result.innerHTML = ''        \--и, когда новый промис разрешиться, уже обрабатываем
14-31   for (const friend of friends) {--сработает обработчик и сделаем работу
            const friendsDOM = createFriendNode(friend)
            result.appendChild(friendsDOM)
        }
    })
})
14-00 .catch(()=>{ ---замечательно впишется старый
        console.error('файл не найден или др.проблемы')
        })
14-41 использовали ф-цю fetch(), кот встроена в браузер
14-50 сожно еще более упростить нагромождение [14-15..14-31]
14-58 ВСПОМНИМ, если возвращаем из1го обратчика .then() другой промис,
15-02 то соотвественно след..then() будет ждать пока этот промис разрешится
15-15 и только потом этот ---^ будет выполнен
15-34 а т.к.конструкция однострочная, то можем заинлайнить
    loadButton.addEventListener('click',()=>{
        fetch('friends.json')
          .then(response =>  response.json())
          .then(friends => {
             result.innerHTML = ''
             for (const friend of friends) {
                const friendsNode = createFriendNode(friend)
                result.appendChild(friendsNode)
                }
             })
           .catch(()=> console.error('файл не найден или др.проблемы'))
        })
15-52 НО мы не делали пока никаких проверок на статус, вернем скобки{}
loadButton.addEventListener('click',()=>{
    fetch('friends.json')
      .then(response => {
16-04    if (response.status >= 400) { --чтобы вставить if(), который уже был на этих проверках
16-19        return [] --то мы возвращаем пустой объект-массив|нечего итерировать
          }
          return response.json()
      })
16-54 возвращать пустой массив - не совсем правильно,
17-00 а надо return Promise.reject(), т.е. выполнено неудачно, т.н."short hand"
17-23 и управление перейдет в catch()

18-02 смотрим на сайте "caniuse.com" поддержку fetch()
18-22 но она прекрасно эмулируется\полифилится
18-40 это некая обертка над XMLHttpRequest, промис-ифицируется, что мы делали вручную
19-05 но смысл остается - асинхонные запросы без перегрузки страницы и
19-10 ответный запрос обрабатывается как удобно
------------------------------
12-4 WebSocket.mp4
0-0 еще 1 способ передавать-получать данные сервера
ранее говорили об асин http запрос-ответах
здесь будум говорить о WebSocket-ах - постоянное соединение с сервером, а не запрос-ответ
даже нет таких понятий, а есть понятие "сообщение", обмен сообщениями в любое время
1-17 саммый популярный пример - чат
1-41 WebSocket-сервер уже развернут
------------------------------
12-5 Service Worker.mp4
0-0 относительно новый подход, веб-стр-ца может работать в оффлайн режиме, без интернета
1-19 а все данные берутся из спец. кеша
1-34 SW - просто скрпт, кот крутится на фоне стр-цы, и задача этого SW обрабатывать запросы стр-цы

------------------------------
12-_12 links.txt

---------------------------------------------------------------------------------------
13 Browser API
---------------------------------------------------------------------------------------
13-1 LocalStorage.mp4
13-2 Cookies.mp4
13-3 Навигация_ hash.mp4
13-4 Навигация_ history.mp4
13-5 File API.mp4
13-_13 Методичка BOM.pdf

---------------------------------------------------------------------------------------
14 Вебинар Практика
14-Вебинар — Практика от 22.02.2020 12_00.mp4
14-Код с вебинара.zip
---------------------------------------------------------------------------------------
15 Работа с VK API и шаблонизация
---------------------------------------------------------------------------------------
15-1 Шаблонизация.mp4
15-15 Методичка — HTML5 API.pdf
15-15 Методичка — SDK.pdf
15-2 VK SDK.mp4
---------------------------------------------------------------------------------------
16 ООП
---------------------------------------------------------------------------------------
16-1 Intro.mp4
16-16 Методичка ООП.pdf
16-2 Инкапсуляция.mp4
16-3 Наследование.mp4
16-4 Полиморфизм.mp4
16-5 Классы.mp4
16-links.txt
---------------------------------------------------------------------------------------
17 Вебинар Практика
17-17 Вебинар.mp4
17-17 Код с вебинара.zip

---------------------------------------------------------------------------------------
18 MV-паттерны
---------------------------------------------------------------------------------------
18-1 Паттерны MV.mp4
18-18 Код с видеокурса MV.zip
18-18 Методичка MV-паттерны.pdf
18-2 MVC.mp4
18-3 MVVM.mp4
---------------------------------------------------------------------------------------
19 Модули
---------------------------------------------------------------------------------------
19-1 Модульность в JS.mp4
19-2 Перевод проекта на модули.mp4
19-3 ES6-модули.mp4
---------------------------------------------------------------------------------------
20 Вебинар Практика
20-20 Вебинар — Практика.mp4
---------------------------------------------------------------------------------------
21 Вебинар Node.js (краткое знакомство)
---------------------------------------------------------------------------------------
21-21 links.txt
21-21 вебинар.mp4
---------------------------------------------------------------------------------------
22 Тестирование JS-кода
---------------------------------------------------------------------------------------
22-1. Тестирование кода from loftschool.mp4
22-2. Jest.mp4
22-22 dop.txt
22-3. Польза тестов.mp4
22-4. Coverage.mp4
---------------------------------------------------------------------------------------
23 Вебинар — Практика (Закрытие)
---------------------------------------------------------------------------------------
23-23 links.txt
23-23 Вебинар Практика (Закрытие).mp4

_homework\01
_homework\02
_homework\03
_homework\04
_homework\05
_homework\06
_homework\01\dz_1.zip
_homework\01\Неделя #1 Настройка окружения, сборка, начало работы _ LoftSchool.pdf
_homework\02\dz3.zip
_homework\02\dz_2
_homework\02\dz_2.zip
_homework\02\Неделя #2 Объекты и массивы. Обработка ошибок _ LoftSchool.pdf
_homework\02\dz_2\dz_2
_homework\02\dz_2\dz_2\src
_homework\02\dz_2\dz_2\test
_homework\02\dz_2\dz_2\src\index.js
_homework\02\dz_2\dz_2\test\index.js
_homework\03\dz4.zip
_homework\03\dz5.zip
_homework\03\Неделя #3 Работа с DOM. DOM Events _ LoftSchool.pdf
_homework\04\dz6.zip
_homework\04\dz7.zip
_homework\04\Неделя #4 Асинхронность и работа с сетью. Создание редактора cookie _ LoftSchool.pdf
_homework\05\geootzyvmaket.zip
_homework\05\video.txt
_homework\05\Неделя #5 Работа над ВП №1 _ LoftSchool.pdf
_homework\06\ВП2.psd
_homework\06\Неделя #6 Работа над ВП №2 _ LoftSchool.pdf

git rm -f .idea/workspace.xml